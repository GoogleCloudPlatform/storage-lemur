// Code generated by protoc-gen-go.
// source: pdm/pdm.proto
// DO NOT EDIT!

/*
Package pdm is a generated protocol buffer package.

It is generated from these files:
	pdm/pdm.proto

It has these top-level messages:
	Endpoint
	Handle
	ActionItem
	ActionStatus
	Empty
*/
package pdm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Command int32

const (
	Command_NONE    Command = 0
	Command_ARCHIVE Command = 1
	Command_RESTORE Command = 2
	Command_REMOVE  Command = 3
	Command_CANCEL  Command = 4
)

var Command_name = map[int32]string{
	0: "NONE",
	1: "ARCHIVE",
	2: "RESTORE",
	3: "REMOVE",
	4: "CANCEL",
}
var Command_value = map[string]int32{
	"NONE":    0,
	"ARCHIVE": 1,
	"RESTORE": 2,
	"REMOVE":  3,
	"CANCEL":  4,
}

func (x Command) String() string {
	return proto.EnumName(Command_name, int32(x))
}
func (Command) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Endpoint struct {
	FsUrl   string `protobuf:"bytes,2,opt,name=fs_url" json:"fs_url,omitempty"`
	Archive uint32 `protobuf:"varint,1,opt,name=archive" json:"archive,omitempty"`
}

func (m *Endpoint) Reset()                    { *m = Endpoint{} }
func (m *Endpoint) String() string            { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()               {}
func (*Endpoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Handle struct {
	Id uint64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *Handle) Reset()                    { *m = Handle{} }
func (m *Handle) String() string            { return proto.CompactTextString(m) }
func (*Handle) ProtoMessage()               {}
func (*Handle) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ActionItem struct {
	Cookie      uint64  `protobuf:"varint,1,opt,name=cookie" json:"cookie,omitempty"`
	Op          Command `protobuf:"varint,2,opt,name=op,enum=pdm.Command" json:"op,omitempty"`
	PrimaryPath string  `protobuf:"bytes,3,opt,name=primary_path" json:"primary_path,omitempty"`
	WritePath   string  `protobuf:"bytes,4,opt,name=write_path" json:"write_path,omitempty"`
	Offset      uint64  `protobuf:"varint,5,opt,name=offset" json:"offset,omitempty"`
	Length      uint64  `protobuf:"varint,6,opt,name=length" json:"length,omitempty"`
	Data        []byte  `protobuf:"bytes,7,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ActionItem) Reset()                    { *m = ActionItem{} }
func (m *ActionItem) String() string            { return proto.CompactTextString(m) }
func (*ActionItem) ProtoMessage()               {}
func (*ActionItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type ActionStatus struct {
	Cookie    uint64  `protobuf:"varint,1,opt,name=cookie" json:"cookie,omitempty"`
	Completed bool    `protobuf:"varint,2,opt,name=completed" json:"completed,omitempty"`
	Error     int32   `protobuf:"varint,3,opt,name=error" json:"error,omitempty"`
	Offset    uint64  `protobuf:"varint,4,opt,name=offset" json:"offset,omitempty"`
	Length    uint64  `protobuf:"varint,5,opt,name=length" json:"length,omitempty"`
	Handle    *Handle `protobuf:"bytes,6,opt,name=handle" json:"handle,omitempty"`
}

func (m *ActionStatus) Reset()                    { *m = ActionStatus{} }
func (m *ActionStatus) String() string            { return proto.CompactTextString(m) }
func (*ActionStatus) ProtoMessage()               {}
func (*ActionStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ActionStatus) GetHandle() *Handle {
	if m != nil {
		return m.Handle
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func init() {
	proto.RegisterType((*Endpoint)(nil), "pdm.Endpoint")
	proto.RegisterType((*Handle)(nil), "pdm.Handle")
	proto.RegisterType((*ActionItem)(nil), "pdm.ActionItem")
	proto.RegisterType((*ActionStatus)(nil), "pdm.ActionStatus")
	proto.RegisterType((*Empty)(nil), "pdm.Empty")
	proto.RegisterEnum("pdm.Command", Command_name, Command_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for DataMover service

type DataMoverClient interface {
	Register(ctx context.Context, in *Endpoint, opts ...grpc.CallOption) (*Handle, error)
	GetActions(ctx context.Context, in *Handle, opts ...grpc.CallOption) (DataMover_GetActionsClient, error)
	StatusStream(ctx context.Context, opts ...grpc.CallOption) (DataMover_StatusStreamClient, error)
}

type dataMoverClient struct {
	cc *grpc.ClientConn
}

func NewDataMoverClient(cc *grpc.ClientConn) DataMoverClient {
	return &dataMoverClient{cc}
}

func (c *dataMoverClient) Register(ctx context.Context, in *Endpoint, opts ...grpc.CallOption) (*Handle, error) {
	out := new(Handle)
	err := grpc.Invoke(ctx, "/pdm.DataMover/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataMoverClient) GetActions(ctx context.Context, in *Handle, opts ...grpc.CallOption) (DataMover_GetActionsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataMover_serviceDesc.Streams[0], c.cc, "/pdm.DataMover/GetActions", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataMoverGetActionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataMover_GetActionsClient interface {
	Recv() (*ActionItem, error)
	grpc.ClientStream
}

type dataMoverGetActionsClient struct {
	grpc.ClientStream
}

func (x *dataMoverGetActionsClient) Recv() (*ActionItem, error) {
	m := new(ActionItem)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataMoverClient) StatusStream(ctx context.Context, opts ...grpc.CallOption) (DataMover_StatusStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataMover_serviceDesc.Streams[1], c.cc, "/pdm.DataMover/StatusStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataMoverStatusStreamClient{stream}
	return x, nil
}

type DataMover_StatusStreamClient interface {
	Send(*ActionStatus) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type dataMoverStatusStreamClient struct {
	grpc.ClientStream
}

func (x *dataMoverStatusStreamClient) Send(m *ActionStatus) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataMoverStatusStreamClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for DataMover service

type DataMoverServer interface {
	Register(context.Context, *Endpoint) (*Handle, error)
	GetActions(*Handle, DataMover_GetActionsServer) error
	StatusStream(DataMover_StatusStreamServer) error
}

func RegisterDataMoverServer(s *grpc.Server, srv DataMoverServer) {
	s.RegisterService(&_DataMover_serviceDesc, srv)
}

func _DataMover_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Endpoint)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DataMoverServer).Register(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DataMover_GetActions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Handle)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataMoverServer).GetActions(m, &dataMoverGetActionsServer{stream})
}

type DataMover_GetActionsServer interface {
	Send(*ActionItem) error
	grpc.ServerStream
}

type dataMoverGetActionsServer struct {
	grpc.ServerStream
}

func (x *dataMoverGetActionsServer) Send(m *ActionItem) error {
	return x.ServerStream.SendMsg(m)
}

func _DataMover_StatusStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataMoverServer).StatusStream(&dataMoverStatusStreamServer{stream})
}

type DataMover_StatusStreamServer interface {
	SendAndClose(*Empty) error
	Recv() (*ActionStatus, error)
	grpc.ServerStream
}

type dataMoverStatusStreamServer struct {
	grpc.ServerStream
}

func (x *dataMoverStatusStreamServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataMoverStatusStreamServer) Recv() (*ActionStatus, error) {
	m := new(ActionStatus)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _DataMover_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pdm.DataMover",
	HandlerType: (*DataMoverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _DataMover_Register_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetActions",
			Handler:       _DataMover_GetActions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StatusStream",
			Handler:       _DataMover_StatusStream_Handler,
			ClientStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 405 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x64, 0x52, 0x4f, 0x6f, 0xd3, 0x30,
	0x14, 0x27, 0x69, 0xfe, 0xf5, 0x35, 0xd9, 0x32, 0x6b, 0x87, 0xa8, 0x5c, 0x50, 0x0e, 0x68, 0x02,
	0xb4, 0xa1, 0xf2, 0x09, 0xaa, 0x60, 0xb1, 0x49, 0xac, 0x95, 0x52, 0xc4, 0x75, 0x32, 0x89, 0xbb,
	0x5a, 0xc4, 0xb1, 0xe5, 0x78, 0x43, 0x3d, 0xf0, 0x15, 0x38, 0xf0, 0x89, 0x71, 0x6c, 0x55, 0x44,
	0x70, 0x88, 0xf4, 0x7e, 0xef, 0x25, 0xbf, 0x3f, 0xef, 0x05, 0x32, 0xd9, 0xf2, 0x1b, 0xf3, 0x5c,
	0x4b, 0x25, 0xb4, 0x40, 0x33, 0x53, 0x96, 0x6f, 0x21, 0xc1, 0x7d, 0x2b, 0x05, 0xeb, 0x35, 0x3a,
	0x83, 0x68, 0x3f, 0x3c, 0x3c, 0xa9, 0xae, 0xf0, 0x5f, 0x79, 0x57, 0x73, 0x74, 0x0e, 0x31, 0x51,
	0xcd, 0x81, 0x3d, 0xd3, 0xc2, 0x33, 0x8d, 0xac, 0xbc, 0x84, 0xe8, 0x96, 0xf4, 0x6d, 0x47, 0x11,
	0x80, 0xcf, 0x5a, 0xdb, 0x0d, 0xca, 0x5f, 0x1e, 0xc0, 0xba, 0xd1, 0x4c, 0xf4, 0x77, 0x9a, 0xf2,
	0x91, 0xa5, 0x11, 0xe2, 0x3b, 0x73, 0x1f, 0x05, 0xa8, 0x00, 0x5f, 0x48, 0xcb, 0x78, 0xb6, 0x4a,
	0xaf, 0x47, 0xf9, 0x4a, 0x70, 0x6e, 0x68, 0xd0, 0x25, 0xa4, 0x52, 0x31, 0x4e, 0xd4, 0xf1, 0x41,
	0x12, 0x7d, 0x28, 0x66, 0x56, 0xd5, 0x70, 0xff, 0x50, 0x4c, 0x53, 0xd7, 0x0b, 0x6c, 0xcf, 0x70,
	0x8a, 0xfd, 0x7e, 0xa0, 0xba, 0x08, 0x2d, 0xa7, 0xc1, 0x1d, 0xed, 0x1f, 0xcd, 0x3c, 0xb2, 0x38,
	0x85, 0xa0, 0x25, 0x9a, 0x14, 0xb1, 0x41, 0x69, 0xf9, 0x13, 0x52, 0xe7, 0x67, 0xa7, 0x89, 0x7e,
	0x1a, 0xfe, 0x73, 0x74, 0x01, 0xf3, 0x46, 0x70, 0xd9, 0x51, 0x4d, 0x5b, 0x6b, 0x2c, 0x41, 0x19,
	0x84, 0x54, 0x29, 0xa1, 0xac, 0x87, 0x70, 0xa2, 0x17, 0xfc, 0xa3, 0xe7, 0xf4, 0x5f, 0x42, 0x74,
	0xb0, 0x8b, 0xb0, 0xfa, 0x8b, 0xd5, 0xc2, 0xe6, 0x72, 0xbb, 0x29, 0x63, 0x08, 0x31, 0x97, 0xfa,
	0xf8, 0x06, 0x43, 0x7c, 0x8a, 0x9a, 0x40, 0xb0, 0xd9, 0x6e, 0x70, 0xfe, 0x02, 0x2d, 0x20, 0x5e,
	0xd7, 0xd5, 0xed, 0xdd, 0x57, 0x9c, 0x7b, 0x23, 0xa8, 0xf1, 0xee, 0xcb, 0xb6, 0xc6, 0xb9, 0x6f,
	0x72, 0x47, 0x35, 0xbe, 0xdf, 0x9a, 0xc1, 0x6c, 0xac, 0xab, 0xf5, 0xa6, 0xc2, 0x9f, 0xf3, 0x60,
	0xf5, 0xdb, 0x83, 0xf9, 0x47, 0x93, 0xee, 0x5e, 0x3c, 0x53, 0x85, 0x5e, 0x43, 0x52, 0xd3, 0x47,
	0x36, 0x68, 0x53, 0x67, 0x56, 0xf6, 0x74, 0xbf, 0xe5, 0xd4, 0x05, 0x7a, 0x07, 0xf0, 0x89, 0x6a,
	0xb7, 0x87, 0x01, 0x4d, 0x47, 0xcb, 0x73, 0x0b, 0xfe, 0x9e, 0xec, 0xbd, 0x87, 0x6e, 0x20, 0x75,
	0xcb, 0xda, 0x69, 0x45, 0x09, 0x47, 0x17, 0x93, 0x57, 0xdc, 0x60, 0x09, 0x4e, 0x6c, 0x4c, 0x76,
	0xe5, 0x7d, 0x8b, 0xec, 0x3f, 0xf4, 0xe1, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xeb, 0x14, 0x98,
	0x46, 0x54, 0x02, 0x00, 0x00,
}
